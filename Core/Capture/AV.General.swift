
import AVFoundation


class Timebase : Session {
    private(set) var date: Date = Date()
    
    override func start() throws {
        date = Date()
    }
}


extension Session.Kind {
    static let avCapture = Session.Kind(rawValue: "avCapture")
    static let encoder = Session.Kind(rawValue: "encoder")
}


extension AVCaptureSession : SessionProtocol {
    func start() throws {
        startRunning()
    }
    
    func stop() {
        print("STOP CAPTURE")
        stopRunning()
    }
}


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Config
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

struct CaptureConfig {
    let fileType: AVFileType
    
    let audioDevice: AVCaptureDevice
    let audioConfig: AudioConfig
    
    let videoDevice: AVCaptureDevice
    let videoFormat: AVCaptureDevice.Format
    let videoConfig: VideoConfig
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Settings
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

struct CaptureSettings {
    let data: [String: Any]
    
    init(_ data: [String: Any]) {
        self.data = data
    }
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Progress
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

protocol CaptureProgress {
    var secondsAvailable: TimeInterval? { get }
    var secondsSinceStart: TimeInterval { get }
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Logging
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

func logAV(_ message: String) {
    logMessage("IO", message)
}

func logAVPrior(_ message: String) {
    logPrior("IO", message)
}

func logAVError(_ error: Error) {
    logError("IO", error)
}

func logAVError(_ error: String) {
    logError("IO", error)
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Broadcast
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

func broadcast<T>(_ x: [T?], create: ([T]) -> T) -> T? {
    var theX = [T]()
    
    for i in x {
        if let i = i {
            theX.append(i)
        }
    }
    
    if (theX.count == 0) {
        return nil
    }
    if (theX.count == 1) {
        return theX[0]
    }
    
    return create(theX)
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Broadcast
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

enum CaptureError : Error {
    case status(code: OSStatus, message: String)
}

func checkStatus(_ status: OSStatus, _ message: String) throws {
    guard status == 0 else {
        throw CaptureError.status(code: status, message: message)
    }
}
